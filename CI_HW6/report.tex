\documentclass[12pt]{article}

\usepackage{xepersian}
\settextfont[Scale=1]{XB Niloofar}
\setlatintextfont[Scale=1]{Times New Roman}
\title{تمرین سری ششم درس مبانی هوش محاسباتی}
\author{کورش تقی‌پور پاسدار}
\begin{document}
	\maketitle
	\section{سوال ۱}
	\subsection{الف}
	\textbf{روند کلی :} یک الگوریتم تکاملی برای یافتن راه‌حل نسبتا بهینه استفاده می‌شود. در الگوریتم تکاملی، یک جمعیتی از کروموزوم ها را داریم که حالت‌های مختلف مساله را بصورت ویژگی‌های رندومی در آنها کد می‌کنیم. در هر نسل، ویژگی‌های قوی‌تر و سازگارتر آنها (با مساله) به نسل بعدی منتقل می‌شود و در نهایت، با رخ دادن شرایط اتمام پروسه (رسیدن به حد نهایی تعداد نسل‌های مجاز یا یافتن راه حل مساله) الگوریتم متوقف می‌شود.
	 \begin{itemize}
	 	\item \lr{Population} به مجموعه تمام نمونه‌ها (کروموزوم‌ها) گفته می‌شود.
	 	\item \lr{Selection} به فرآیندی گفته می‌شود که در آن انتخاب کنیم کدام کروموزوم‌ها به تنهایی یا با هم تشکیل فرزند و نسل بعدی را بدهند.
	 	\item \lr{Variation Operations} به فرآیندهایی گفته می‌شود که نحوه تشکیل فرزند از کروموزوم‌های انتخاب شده نسل فعلی را  بیان می‌کنند.
	 	\item \lr{Fitness evaluation} تابعی است که مشخص می‌کند هر کروموزوم چقدر ویژگی‌های مطلوب را دارد.
	 	\item \lr{Termination criteria} به معیارهای اتمام الگوریتم گفته می‌شود.
	 \end{itemize}
	 \subsection{ب}
	 الگوریتم‌های ژنتیک به الگوریتم‌هایی گفته می‌شود که از اصول ژنتیک و انتخاب طبیعی برای حل مسائل بهینه‌سازی استفاده می‌کنند. این الگوریتم‌ها در مسائلی مانند بهینه‌سازی پارامترها (مانند تنظیم پارامترهای مدل‌های یادگیری ماشین)، مسائل مسیریابی و طراحی سیستم‌ها کاربرد دارد. 
	 
	 برنامه‌ریزی ژنتیک به نوعی خاص از الگوریتم‌های ژنتیک گفته می‌شود که به تکامل ساختار برنامه‌های کامپیوتری می‌پردازد. از  کاربردهای برنامه‌ریزی ژنتیک می‌توان به تولید خودکار کد، بهینه‌سازی الگوریتم‌ها و مدل‌سازی و شبیه‌سازی اشاره کرد.
	 
	 از تفاوت‌های آنها می‌توان به این اشاره کرد که الگوریتم‌های ژنتیک برای بهینه‌سازی پارامترها بکار می‌رود درحالیکه برنامه‌ریزی ژنتیک در ساختار برنامه‌های کامپیوتری بکار می‌رود. از طرفی، راه‌حل‌ها در الگوریتم‌های ژنتیک بصورت رشته‌ای از ژن‌ها نشان داده می‌شوند ولی در برنامه‌ریزی ژنتیک بصورت درخت‌های برنامه نمایش داده می‌شوند.
	 \section{سوال ۲}
	 \subsection{الف}
	 در بهینه سازی ذرات، ما به دنبال یافتن حالت بهینه‌ی مساله هستیم. برای همین منظور،  از تعداد زیادی ذرات رندوم پخش شده در فضای حالت استفاده می‌کنیم. این ذرات با استفاده از اطلاعات کسب شده خودشان و اطلاعات جمعی، ‌به سمت بهترین حالت حرکت می‌کنند.
	 \begin{itemize}
	 	\item \textbf{\lr{Particle}} به هر ذره‌ی شرکت کننده در این الگوریتم گفته می‌شود که سعی دارد به سمت بهترین حالت حرکت کند.
	 	\item \textbf{\lr{Velocity}} به سرعت هر ذره گفته می‌شود و به عبارت دیگر، بیان می‌کند هر ذره در فضای حالت به کدام سمت حرکت می‌کند.
	 	\item \textbf{\lr{Position Update}} به تغییر مکان هر ذره گفته می‌شود که این تغییر مکان به سرعت قبلی، \lr{Personal Best} و \lr{Global Best} ربط دارد.
	 	\item \textbf{\lr{Personal Best and Global Best}} به ترتیب به بهترین حالت یافت شده توسط هر ذره و بهترین حالت یافت شده توسط تمام ذرات گفته می‌شود.
	 \end{itemize}
	 \subsection{ب}
	 \subsubsection{تکرار اول}
	 در ابتدا مقدار تابع \lr{g(x)} را برای مکان‌های فعلی ذرات حساب می‌کنیم.
	 \begin{eqnarray*}
	 	g(x_{1}) &=& -(2-5)^{2} + 10 = 1\\
	 	g(x_{2}) &=& -(11-5)^{2} + 10 = -26
	 \end{eqnarray*}
	 در این مرحله \lr{Personal Best} برای هر ذره مکان فعلی و \lr{Global Best} برابر با $x=2$ می‌باشد.
	 
	 حال به محاسبه سرعت جدید و به تبع، مکان جدید ذرات می‌پردازیم.
	 \begin{eqnarray*}
	 	v_{1} &=& 0.5 \times 1 + 1.5\times 0.4 \times (2-2) + 1.5 \times 0.7 \times (2 - 2) = 0.5\\
	 	v_{2} &=& 0.5 \times -2 + 1.5\times 0.4\times(11 - 11) + 1.5\times 0.7\times(2 - 11) = -10.45\\
	 	x_{1} &=& 2 + 0.5 = 2.5\\
	 	x_{2} &=& 11 + (-10.45) = 0.55
	 \end{eqnarray*}
	 \subsubsection{تکرار دوم}
	 دوباره مقدار تابع \lr{g(x)} را برای مکان‌های فعلی ذرات حساب می‌کنیم.
	 \begin{eqnarray*}
	 	g(x_{1}) &=& -(2.5-5)^{2} + 10 = 3.75\\
	 	g(x_{2}) &=& -(0.55 - 5)^{2} + 10 = -9.8025
	 \end{eqnarray*}
	 در این مرحله \lr{Personal Best} برای هر ذره بازهم مکان فعلی و \lr{Global Best} نیز برابر با $x=2.5$ می‌باشد.
	 
	 حال به محاسبه سرعت جدید و مکان جدید ذرات می‌پردازیم.
	 \begin{eqnarray*}
	 	v_{1} &=& 0.5\times 0.5 + 1.5\times 0.4\times(2.5 - 2.5)\\
	 	&+& 1.5\times 0.7\times(2.5 - 2.5) = 0.25\\
	 	v_{2} &=& 0.5\times -10.45 + 1.5\times 0.4\times (0.55 - 0.55)\\
	 	&+& 1.5\times 0.7 \times(2.5 - 0.55) = -3.1775\\
	 	x_{1} &=& 2.5 + 0.25 = 2.75\\
	 	x_{2} &=& 0.55 - 3.1775 = -2.6275
	 \end{eqnarray*}
	 \subsubsection{تکرار سوم}
	 مقدار تابع \lr{g(x)} را برای مکان‌های فعلی ذرات حساب می‌کنیم.
	 \begin{eqnarray*}
	 	g(x_{1}) &=& -(2.75-5)^{2} + 10 = 4.9375\\
	 	g(x_{2}) &=& -(-2.6275-5)^{2} + 10 = -48.18
	 \end{eqnarray*}
	 در این مرحله، \lr{Personal Best} برای ذرات $x_{1}$ و $x_{2}$ به ترتیب \lr{2.75} و \lr{0.55} می‌باشد. همچنین \lr{Global Best} هم برابر با \lr{2.75} می‌باشد.
	 
	 محاسبه سرعت جدید و مکان جدید:
	 \begin{eqnarray*}
	 	v_{1} &=& 0.5\times 0.25 + 1.5\times 0.4\times (2.75 - 2.75)\\
	 	&+& 1.5\times 0.7\times (2.75 - 2.75) = 0.125\\
	 	v_{2} &=& 0.5\times -3.1775 + 1.5\times 0.4\times (0.55 - (-2.6275))\\
	 	&+& 1.5\times 0.7\times (2.75 - (-2.6275)) = 5.96\\
	 	x_{1} &=& 2.75 + 0.125 = 2.875\\
	 	x_{2} &=& -2.6275 +5.96 = 3.33
	 \end{eqnarray*}
	 حال در پایان باز به محاسبه \lr{g(x)} می‌پردازیم تا بهترین نقطه‌ی پیدا شده (تاکنون) را مشخص کنیم.
	 \begin{eqnarray*}
	 	g(x_{1}) &=& -(2.875 - 5)^{2} + 10 = 5.48\\
	 	g(x_{2}) &=& -(3.33 - 5)^{2} + 10 = 7.2
	 \end{eqnarray*}
	 با بررسی تمام \lr{g(x)}های محاسبه شده، بهترین \lr{g(x)} بدست آمده برابر با \lr{7.2} و در نتیجه بهترین \lr{x} بدست آمده برابر با \lr{3.33} می‌باشد.
	 \section{سوال ۳}
	 \subsection{الف}
	 در دنیای واقعی، مورچه‌ها با انتشار فرمون‌ها \LTRfootnote{\lr{Phermone}} میان مسیرهای متفاوت، تمایز قائل می‌شوند. مورچه‌ها با عبور از هر مسیری‌ اقدام به ترشح فرمون می‌کنند. حال هر قدر یک مسیری بهینه‌تر باشد، به تدریج مورچه‌های بیشتری از آن عبور کرده و مقدار ترشح فرمون در آن مسیر بیشتر خواهد شد و مسیر بهینه‌تر پیدا خواهد شد. در الگوریتم‌های  \lr{ACO} نیز از همین ترفند استفاده کرده و بجای فرمون از احتمال استفاده می‌کند به اینصورت که هر مسیری فرمون بیشتری داشته باشد، احتمال انتخاب شدن آن مسیر بیشتر است.
	 \begin{itemize}
	 	\item \lr{Phermone} در این الگوریتم، فرمون به عنوان احتمال انتخاب شدن یک مسیر عمل می‌کند و هرقدر فرمون یک مسیر بیشتر باشد، احتمال انتخاب شدن آن مسیر هم بیشتر است.
	 	\item \lr{heuristic information} معمولا براساس اطلاعات قبلی بدست آمده است که همراه با فرمون‌ها در انتخاب مسیر بهینه تاثیرگذار است. 
	 \end{itemize}
	 \subsection{ب}
	 \begin{eqnarray*}
	 	P_{AB} &=& \frac{1^{1}\times (\frac{1}{2})^{2}}{\sum_{k \in \mathcal{N_{A}}} \tau_{Ak}^{1} \times \mu_{Ak}^{2}}
	 	= \frac{\frac{1}{4}}{\frac{261}{784}}=\frac{784}{1044}\\
	 	P_{AC} &=& \frac{1^{1}\times (\frac{1}{4})^{2}}{\sum_{k \in \mathcal{N_{A}}} \tau_{Ak}^{1} \times \mu_{Ak}^{2}}
	 	= \frac{\frac{1}{16}}{\frac{261}{784}}=\frac{784}{4176}\\
	 	P_{AD} &=& \frac{1^{1}\times (\frac{1}{7})^{2}}{\sum_{k \in \mathcal{N_{A}}} \tau_{Ak}^{1} \times \mu_{Ak}^{2}}
	 	= \frac{\frac{1}{49}}{\frac{261}{784}}=\frac{784}{12789}
	 \end{eqnarray*}
	 مورچه به احتمال زیاد از گره \lr{B} عبور خواهد کرد.
\end{document}